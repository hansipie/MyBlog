[{"categories":["DIY"],"content":"De Windows Ã  Linux : quand dÃ©velopper pour Android devient un parcours du combattantâ€¦ mais pas insurmontable.\nLe point de dÃ©part : un besoin simple, une envie dâ€™Ã©volution Jâ€™avais besoin de dÃ©velopper pour Android. Rien dâ€™extraordinaire, une tÃ¢che que jâ€™ai rÃ©alisÃ©e des centaines de fois sous Windows. Installer Android Studio, crÃ©er un Ã©mulateur, lancer lâ€™application, et voilÃ . Un processus rodÃ©, fluide, presque ennuyeux de simplicitÃ©.\nMais voilÃ , jâ€™Ã©tais en pleine migration vers Linux. AprÃ¨s des annÃ©es sous Windows, jâ€™avais dÃ©cidÃ© de franchir le pas et de basculer sur Bazzite, une distribution Linux â€œatomiqueâ€ basÃ©e sur Fedora. Le genre de distribution moderne qui promet stabilitÃ© et fiabilitÃ© grÃ¢ce Ã  un systÃ¨me de fichiers racine en lecture seule.\nNaÃ¯vement, je pensais que ce serait aussi simple que sous Windows. Spoiler : Ã§a ne lâ€™a pas Ã©tÃ©.\nLes contraintes : bienvenue dans le monde atomique PremiÃ¨re dÃ©couverte : avec un systÃ¨me atomique, impossible dâ€™installer des outils de dÃ©veloppement directement sur le systÃ¨me hÃ´te. Le systÃ¨me de fichiers racine est verrouillÃ©, immuable. Câ€™est le prix Ã  payer pour la stabilitÃ©.\nLa solution ? Distrobox. Un outil qui permet de crÃ©er des conteneurs lÃ©gers oÃ¹ lâ€™on peut installer tout ce quâ€™on veut. En gros, une petite bulle Ubuntu (jâ€™ai choisi Ubuntu pour sa compatibilitÃ©) qui tourne dans mon systÃ¨me Bazzite.\n1 2 3 # CrÃ©er un environnement de dÃ©veloppement distrobox create --name dev-android --image ubuntu:22.04 distrobox enter dev-android PremiÃ¨re contrainte acceptÃ©e. Pas le choix de toute faÃ§on.\nLe faux sentiment de victoire : Android Studio installÃ© ! Dans mon conteneur Ubuntu fraÃ®chement crÃ©Ã©, jâ€™ai installÃ© Android Studio. TÃ©lÃ©chargement du SDK, installation des outils, crÃ©ation dâ€™un Virtual Device (AVD)â€¦ tout sâ€™est dÃ©roulÃ© sans accroc. Lâ€™interface sâ€™affichait correctement, les menus rÃ©pondaient, les paramÃ¨tres se configuraient.\nJâ€™Ã©tais satisfait. Presque trop. â€œFinalement, Linux ce nâ€™est pas si compliquÃ©â€, me disais-je.\nEt puis jâ€™ai cliquÃ© sur le bouton â€œPlayâ€ pour lancer lâ€™Ã©mulateur.\nLe mur : lâ€™Ã©mulateur refuse obstinÃ©ment de dÃ©marrer Segmentation fault.\nDeux mots qui font froid dans le dos de tout dÃ©veloppeur. Lâ€™Ã©mulateur plantait avant mÃªme de sâ€™afficher. Jâ€™ai rÃ©essayÃ©. MÃªme rÃ©sultat. Encore. Toujours pareil.\nJâ€™ai commencÃ© Ã  creuser. Forums, documentation Android, Stack Overflowâ€¦ Les heures ont dÃ©filÃ©.\nLes sources de friction : comprendre pourquoi Ã§a ne marche pas 1. La guerre des drivers graphiques Lâ€™Ã©mulateur Android utilise QEMU avec accÃ©lÃ©ration GPU. ProblÃ¨me : dans mon conteneur Ubuntu, les drivers Mesa (les drivers graphiques open-source) sont ceux dâ€™Ubuntu. Mais mon GPU, lui, est gÃ©rÃ© par les drivers de lâ€™hÃ´te Bazzite (Fedora).\nCette incompatibilitÃ© entre les versions de Mesa crÃ©ait des conflits insurmontables. Le conteneur essayait dâ€™utiliser des drivers qui ne correspondaient pas au matÃ©riel rÃ©el.\n2. SELinux, le garde-chiourme Bazzite utilise SELinux, le systÃ¨me de sÃ©curitÃ© de Red Hat/Fedora. Et SELinux nâ€™aime pas quâ€™on exÃ©cute du code depuis le heap (la mÃ©moire dynamique). Devinez ce que fait lâ€™Ã©mulateur Android ? Exactement Ã§a.\nSELinux bloquait lâ€™Ã©mulateur avant mÃªme quâ€™il puisse vraiment dÃ©marrer.\n3. La virtualisation imbriquÃ©e, ou lâ€™enfer dans lâ€™enfer Lancer lâ€™Ã©mulateur depuis un conteneur, câ€™est crÃ©er une chaÃ®ne de virtualisation :\nMon PC (matÃ©riel rÃ©el) â†’ Conteneur Podman/Distrobox â†’ QEMU (lâ€™Ã©mulateur Android) Trois couches de virtualisation. Câ€™est comme essayer de courir un marathon avec des chaussures deux tailles trop petites et un sac de 20 kg sur le dos. Techniquement possible, mais atrocement inefficace.\n4. KVM et les permissions Lâ€™Ã©mulateur Android a besoin de KVM (Kernel-based Virtual Machine) pour la virtualisation matÃ©rielle. Bien que /dev/kvm soit partagÃ© avec le conteneur, les permissions et les groupes dâ€™utilisateurs nâ€™Ã©taient pas correctement mappÃ©s entre lâ€™hÃ´te et le conteneur.\n5. Qt et lâ€™affichage graphique Lâ€™interface de lâ€™Ã©mulateur utilise Qt. Dans le conteneur, les variables dâ€™environnement QT_QPA_PLATFORM et DISPLAY nâ€™Ã©taient pas correctement configurÃ©es. Lâ€™Ã©mulateur ne savait tout simplement pas oÃ¹ et comment afficher sa fenÃªtre.\nLâ€™illumination : sortir du conteneur AprÃ¨s avoir passÃ© des heures Ã  essayer de rÃ©parer ce qui semblait irrÃ©parable, jâ€™ai eu une idÃ©e contre-intuitive : et si je nâ€™exÃ©cutais pas lâ€™Ã©mulateur dans le conteneur ?\nLa solution Ã©tait lÃ , dans la documentation de Distrobox : distrobox-host-exec. Une commande qui permet dâ€™exÃ©cuter des programmes directement sur lâ€™hÃ´te, depuis le conteneur.\nLâ€™architecture de la solution â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ HÃ´te Bazzite â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ â”‚ Android Emulator (via distrobox-host-exec) â”‚ â”‚ â”‚ â”‚ - AccÃ¨s direct GPU â”‚ â”‚ â”‚ â”‚ - AccÃ¨s direct KVM â”‚ â”‚ â”‚ â”‚ - AccÃ¨s direct Ã  l'affichage â”‚ â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚ â–² â”‚ â”‚ â”‚ â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ â”‚ Conteneur Distrobox (Ubuntu) â”‚ â”‚ â”‚ â”‚ - Android Studio (interface) â”‚ â”‚ â”‚ â”‚ - SDK Tools â”‚ â”‚ â”‚ â”‚ - ADB, Gradle, etc. â”‚ â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ Android Studio reste dans le conteneur, oÃ¹ il est facile Ã  maintenir et Ã  configurer. Mais lâ€™Ã©mulateur, lui, tourne sur lâ€™hÃ´te avec accÃ¨s direct au GPU, Ã  KVM, et Ã  lâ€™affichage.\nLe script magique Jâ€™ai crÃ©Ã© un script shell qui fait le pont entre les deux mondes :\n1 2 3 4 5 6 7 8 9 10 11 12 #!/bin/bash # Variables d'environnement essentielles AVD_HOME=\"$HOME/.android/avd\" EMULATOR=\"/opt/android-sdk/emulator/emulator\" AVD_NAME=\"${1:-Pixel_8_API_34}\" # La commande qui change tout EMULATOR_CMD=\"export QT_QPA_PLATFORM=xcb \u0026\u0026 export DISPLAY=:0 \u0026\u0026 export ANDROID_AVD_HOME=$AVD_HOME \u0026\u0026 $EMULATOR -avd $AVD_NAME -no-snapshot -gpu host\" # ExÃ©cution sur l'hÃ´te depuis le conteneur distrobox-host-exec bash -c \"$EMULATOR_CMD\" Les Ã©lÃ©ments clÃ©s :\nQT_QPA_PLATFORM=xcb : Force Qt Ã  utiliser X11 au lieu de Wayland DISPLAY=:0 : SpÃ©cifie lâ€™affichage de lâ€™hÃ´te -gpu host : Utilise le GPU rÃ©el, pas une Ã©mulation -no-snapshot : Ã‰vite les problÃ¨mes de persistance distrobox-host-exec : La clÃ© de voÃ»te qui exÃ©cute tout Ã§a sur lâ€™hÃ´te Et Ã§a marche ! AprÃ¨s des heures de frustration, lâ€™Ã©mulateur sâ€™est enfin lancÃ©. Fluide, rapide, exactement comme sous Windows. Jâ€™ai pu dÃ©ployer mes applications, tester, debugger. Tout fonctionnait.\nConclusion : Linux, lâ€™amour vache VoilÃ . Jâ€™avais mon environnement de dÃ©veloppement Android fonctionnel sur Linux. Mais Ã  quel prix ?\nSous Windows, tout Ã§a aurait pris 30 minutes. TÃ©lÃ©charger, installer, lancer. Point final. Windows est conÃ§u pour Ãªtre â€œuser-friendlyâ€, pour que tout fonctionne â€œout of the boxâ€. Et Ã§a marche. Câ€™est indÃ©niable.\nLinux, lui, ne fait pas de cadeaux. Il ne mÃ¢che pas le travail. Il faut comprendre ce quâ€™on fait, pourquoi les choses plantent, comment le systÃ¨me fonctionne en profondeur. Câ€™est frustrant. Câ€™est chronophage. Parfois, câ€™est Ã©puisant.\nMais il y a toujours une solution.\nCâ€™est Ã§a, la philosophie Linux. Rien nâ€™est impossible si on se donne les moyens de comprendre et de chercher. La communautÃ© est lÃ , la documentation existe, les outils sont puissants. Mais il faut accepter de mettre les mains dans le cambouis.\nPour certains, câ€™est un repoussoir. Pour dâ€™autres, câ€™est exactement ce quâ€™ils cherchent : le contrÃ´le total, la comprÃ©hension profonde, la satisfaction dâ€™avoir rÃ©solu un problÃ¨me complexe.\nMa migration de Windows vers Linux ? Elle continue. Avec ses hauts et ses bas. Ses victoires et ses frustrations. Mais au final, je ne regrette rien. Parce que chaque problÃ¨me rÃ©solu est une leÃ§on apprise. Et Ã§a, aucun assistant Windows ne pourra jamais me lâ€™offrir.\nğŸ”§ Ressources utiles Pour ceux qui voudraient se lancer dans lâ€™aventure :\nDocumentation Distrobox Guide distrobox-host-exec Documentation Bazzite Troubleshooting Android Emulator Commandes utiles :\n1 2 3 4 5 6 7 8 9 10 11 # VÃ©rifier si KVM est disponible ls -la /dev/kvm # VÃ©rifier l'Ã©tat SELinux getenforce # Lister les Ã©mulateurs disponibles emulator -list-avds # Lancer l'Ã©mulateur avec le script ./android-emulator.sh Nom_De_Votre_AVD ","description":"Lâ€™histoire dâ€™une migration de Windows vers Linux et des dÃ©fis inattendus pour faire tourner lâ€™Ã©mulateur Android","tags":["Dev","Linux","Android","Distrobox"],"title":"Android Emulator sur Bazzite : Quand Linux met des bÃ¢tons dans les roues (et comment sâ€™en sortir)","uri":"/posts/2026-01-16-android-emulator-distrobox/"},{"categories":[],"content":"Jâ€™ai dÃ©veloppÃ© un client FTP en Rust en une semaine (sans connaÃ®tre Rust) : Retour dâ€™expÃ©rience sur le â€œVibe Codingâ€\nIntroduction : Le pari du dÃ©butant complet Et si je vous disais quâ€™il est possible de dÃ©velopper un client FTP/FTPS/SFTP complet et fonctionnel en Rustâ€¦ en une semaineâ€¦ sans avoir jamais Ã©crit une ligne de Rust auparavant ?\nCâ€™est exactement ce que jâ€™ai fait en novembre 2025, armÃ© uniquement de mon expÃ©rience de dÃ©veloppeur senior et de lâ€™assistance dâ€™outils dâ€™IA comme Claude et GitHub Copilot. Cette expÃ©rience mâ€™a permis de tester concrÃ¨tement les limites et les possibilitÃ©s du â€œvibe codingâ€ - cette nouvelle approche oÃ¹ lâ€™IA gÃ©nÃ¨re du code Ã  partir de descriptions en langage naturel.\nSpoiler alert : Les rÃ©sultats sont Ã  la fois impressionnants et rÃ©vÃ©lateurs des limites actuelles de lâ€™IA en dÃ©veloppement logiciel.\nJour 1 : Du zÃ©ro au MVP en moins de 24 heures Un dÃ©marrage fulgurant Le premier jour a Ã©tÃ© une rÃ©vÃ©lation. MalgrÃ© ma totale mÃ©connaissance de Rust - pas mÃªme un â€œHello Worldâ€ Ã  mon actif - jâ€™ai rÃ©ussi Ã  mettre en place un MVP fonctionnel en moins dâ€™une journÃ©e :\nStructure CLI : Initialisation du projet et gestion des arguments en ligne de commande Protocoles de base : Connexion et transfert de fichiers via FTP et SFTP Confort immÃ©diat : IntÃ©gration de rustyline pour lâ€™historique des commandes et lâ€™auto-complÃ©tion, et owo-colors pour un terminal colorÃ© Le rÃ´le crucial de lâ€™IA Lâ€™IA a Ã©tÃ© dÃ©terminante Ã  ce stade. Elle mâ€™a permis de :\nGÃ©nÃ©rer rapidement des structures et modules Rust idiomatiques Comprendre les concepts fondamentaux comme le cÃ©lÃ¨bre borrow checker de Rust DÃ©bugger rapidement les erreurs de compilation sans passer des heures dans la documentation Constat : Pour un dÃ©veloppeur expÃ©rimentÃ©, lâ€™IA supprime complÃ¨tement la barriÃ¨re dâ€™entrÃ©e dâ€™un nouveau langage. On peut Ãªtre productif immÃ©diatement.\nJours 2-4 : Lâ€™explosion fonctionnelle Une vÃ©locitÃ© impressionnante Une fois le MVP en place, le rythme sâ€™est accÃ©lÃ©rÃ© de maniÃ¨re spectaculaire. En deux jours, mon client FTP simple est devenu une application riche en fonctionnalitÃ©s.\nFonctionnalitÃ©s avancÃ©es Transferts en arriÃ¨re-plan : ImplÃ©mentation complexe permettant de lancer des tÃ©lÃ©chargements (get file \u0026) tout en continuant Ã  naviguer dans lâ€™arborescence.\nOpÃ©rations batch : Ajout des commandes mget et mput avec support des wildcards et de la rÃ©cursivitÃ© (-r).\nGestion des tÃ¢ches : Commandes jobs et cancel pour piloter les transferts longs.\nExpÃ©rience utilisateur soignÃ©e Bookmarks : SystÃ¨me de sauvegarde des connexions favorites Listings enrichis : Affichage tabulaire triable avec icÃ´nes et couleurs Auto-complÃ©tion intelligente : Suggestions contextuelles pour les chemins locaux et distants Robustesse et sÃ©curitÃ© RÃ©silience : Reconnexion automatique et mÃ©canismes de retry SÃ©curitÃ© : IntÃ©gration du crate zeroize pour nettoyer les mots de passe en mÃ©moire La magie de lâ€™IA pour les features isolÃ©es Ces ajouts se sont faits avec une fluiditÃ© remarquable. Lâ€™IA excellait dans la gÃ©nÃ©ration de code Rust idiomatique pour des fonctionnalitÃ©s bien dÃ©limitÃ©es. Je formulais une demande (â€œAjoute une commande pour gÃ©rer les bookmarks avec sauvegarde sur disqueâ€), et quelques minutes plus tard, jâ€™avais du code fonctionnel.\nJours 5-7 : La stabilisation etâ€¦ les limites de lâ€™IA Le besoin de rigueur AprÃ¨s lâ€™euphorie de lâ€™ajout de fonctionnalitÃ©s, les derniers jours ont Ã©tÃ© consacrÃ©s Ã  la consolidation. Câ€™est lÃ  que la dynamique a changÃ©.\nLe 18 novembre, jâ€™ai dÃ©cidÃ© de me concentrer sur la qualitÃ© du code :\nSÃ©curitÃ© de la concurrence : CrÃ©ation de mutex_utils pour Ã©liminer les dangereux unwrap() sur les locks Tests unitaires : Ã‰criture dâ€™une suite de tests pour les modules critiques Documentation : Ajout de commentaires et documentation inline La grande limite : Le refactoring Le 19 novembre, jâ€™ai Ã©tabli un plan de refactoring complet. Câ€™est ici que les limites de lâ€™assistance IA sont devenues flagrantes.\nLes piÃ¨ges de lâ€™IA en refactoring Surengineering systÃ©matique : Les propositions de lâ€™IA tombaient souvent dans lâ€™excÃ¨s dâ€™abstraction. Patterns complexes, traits inutiles, architectures over-engineered pour un projet de cette taille.\nManque de cohÃ©rence globale : Lâ€™IA nâ€™a pas de vÃ©ritable comprÃ©hension contextuelle sur la durÃ©e. Elle propose des solutions localement correctes mais qui peuvent entrer en conflit avec des dÃ©cisions architecturales prises prÃ©cÃ©demment.\nBiais vers la complexitÃ© : LÃ  oÃ¹ une solution simple aurait suffi, lâ€™IA suggÃ©rait systÃ©matiquement des approches â€œenterprise-gradeâ€ inadaptÃ©es.\nLâ€™expertise humaine indispensable Câ€™est finalement mon expÃ©rience de dÃ©veloppeur senior qui a permis de :\nStructurer un plan de refactoring cohÃ©rent et progressif Simplifier lâ€™architecture plutÃ´t que de lâ€™alourdir Prioriser la stabilitÃ© (tests, gestion dâ€™erreurs) sur la complexitÃ© technique LeÃ§on importante : Lâ€™IA peut gÃ©nÃ©rer du code rapidement, mais câ€™est le dÃ©veloppeur qui doit maintenir la vision dâ€™ensemble et la cohÃ©rence architecturale.\nConclusion : Lâ€™IA comme turbo, pas comme pilote automatique Ce que lâ€™IA fait exceptionnellement bien âœ… DÃ©marrage rapide : Passer de zÃ©ro Ã  un MVP en quelques heures dans un langage inconnu\nâœ… Exploration : DÃ©couvrir un Ã©cosystÃ¨me (les crates Rust) sans passer des semaines Ã  lire la doc\nâœ… Production vÃ©loce : Ajouter des fonctionnalitÃ©s isolÃ©es Ã  un rythme soutenu\nâœ… DÃ©blocage : RÃ©soudre rapidement les erreurs de compilation et comprendre les concepts\nCe que lâ€™IA ne sait pas (encore) faire âŒ Refactoring cohÃ©rent : Maintenir une vision architecturale sur la durÃ©e\nâŒ DÃ©cisions de design : Arbitrer entre simplicitÃ© et complexitÃ© selon le contexte\nâŒ Jugement expÃ©rimentÃ© : Savoir quand sâ€™arrÃªter et Ã©viter le surengineering\nLe verdict final Cette expÃ©rience valide une hypothÃ¨se : lâ€™IA est un multiplicateur de productivitÃ© formidable, mais elle ne remplace pas lâ€™expertise humaine.\nPour un dÃ©veloppeur senior :\nLâ€™IA Ã©limine la courbe dâ€™apprentissage initiale dâ€™un nouveau langage Elle accÃ©lÃ¨re drastiquement la phase de dÃ©veloppement de features Mais elle nÃ©cessite un pilotage constant et des dÃ©cisions architecturales humaines Pour un dÃ©veloppeur junior ou dÃ©butant, les risques sont plus importants :\nDifficultÃ© Ã  Ã©valuer la qualitÃ© du code gÃ©nÃ©rÃ© Tendance Ã  accepter le surengineering proposÃ© Manque de recul pour simplifier et refactorer efficacement Lâ€™avenir du dÃ©veloppement ? Le â€œvibe codingâ€ nâ€™est pas du dÃ©veloppement paresseux - câ€™est du dÃ©veloppement accÃ©lÃ©rÃ© mais exigeant. Il faut plus que jamais :\nUne vision claire de ce quâ€™on construit La capacitÃ© Ã  Ã©valuer et challenger les propositions de lâ€™IA Lâ€™expertise pour simplifier plutÃ´t que complexifier Lâ€™IA permet dâ€™aller vite. Lâ€™expertise humaine garantit quâ€™on va dans la bonne direction.\nLe projet RustyFTP est disponible en open source. Nâ€™hÃ©sitez pas Ã  explorer le code pour voir concrÃ¨tement ce quâ€™une semaine de â€œvibe codingâ€ peut produire.\nPour les curieux : ğŸ“¦ TÃ©lÃ©charger et explorer le code sur GitHub\nPour aller plus loin Questions ouvertes :\nComment lâ€™IA Ã©voluera-t-elle pour mieux gÃ©rer le refactoring et la cohÃ©rence architecturale ? Quelles nouvelles compÃ©tences les dÃ©veloppeurs doivent-ils cultiver dans ce nouveau paradigme ? Ã€ quel point peut-on sâ€™appuyer sur lâ€™IA pour apprendre un langage â€œprofondÃ©mentâ€ ? Votre expÃ©rience : Avez-vous tentÃ© des projets similaires avec lâ€™assistance de lâ€™IA ? Quelles ont Ã©tÃ© vos dÃ©couvertes et vos limites ? Partagez vos retours en commentaire !\n","description":"","tags":["AI","Projet","Dev"],"title":"Mon retour sur le Vibe Coding","uri":"/posts/2025-11-21-mon-retour-sur-le-vibe-coding/"},{"categories":["application"],"content":"ğŸ§  Le calcul mental, une compÃ©tence essentielleâ€¦ et en dÃ©clin ! ğŸ§ \nAujourdâ€™hui, lâ€™importance du calcul mental va bien au-delÃ  des mathÃ©matiques scolaires : il renforce la confiance en soi, la concentration, la rapiditÃ© de raisonnement et prÃ©pare efficacement les cerveaux Ã  de nombreux dÃ©fis cognitifs .\nPourtant, plusieurs Ã©tudes et rapports dâ€™enseignants alertent : les compÃ©tences en calcul mental dÃ©croissent de faÃ§on inquiÃ©tante, faute de pratique rÃ©guliÃ¨re et dâ€™apprentissage des tables.\nğŸ‰ DÃ©couvrez Papimathic : le coup de boost ludique du calcul mental Papimathic est une application mobile conÃ§ue pour redonner aux enfants (et Ã  leurs parents) le goÃ»t du calcul mental, avec :\nâœ… Pratique des 4 opÃ©rations fondamentales (addition, soustraction, multiplication, division) ğŸŒŸ Feedback instantanÃ© : seconde chance, Ã©toiles, animations motivantes â›°ï¸ 5 niveaux pour progresser Ã  son propre rythme ğŸ”¢ Mode Tables pour maÃ®triser les bases de faÃ§on structurÃ©e ğŸ¨ Interface rÃ©tro et attachante, conÃ§ue avec des experts pÃ©dagogiques et testÃ©e par des enfants Pourquoi lâ€™adopter dÃ¨s maintenant ? ğŸ’¡ Stimule la rapiditÃ© et la prÃ©cision tout en renforÃ§ant la confiance en soi ğŸ§  Aide Ã  dÃ©velopper la fluiditÃ© mathÃ©matique, socle intellectuel essentiel ğŸ“± Facile Ã  utiliser : parfait en courtes sessions, Ã  la maison ou en dÃ©placement ğŸ† Encourage lâ€™engagement grÃ¢ce Ã  un systÃ¨me de rÃ©compenses visuelles ğŸ‘‰ Papimathic est disponible dÃ¨s aujourdâ€™hui sur Android. Donnez Ã  vos enfants (et Ã  vous-mÃªme !) un coup de pouce ludique pour faire des maths autrement.\nğŸ”— TÃ©lÃ©chargez Papimathic maintenant ğŸ” Aimez, commentez ou partagez ce post pour aider dâ€™autres parents, enseignants et Ã©ducateurs Ã  redÃ©couvrir la puissance du calcul mental !\n","description":"","tags":["Dev","Expo"],"title":"Papimathic: le coup de boost ludique du calcul mental","uri":"/posts/2025-06-23-unlocking-papimathic-key-concepts-and-benefits/"},{"categories":["application"],"content":"\n","description":"","tags":["Dev","Expo"],"title":"SmartComments","uri":"/posts/2025-05-14-smartcomments/"},{"categories":["DIY"],"content":"Il existe dans le commerce des routeurs VPN prÃªts Ã  lâ€™emploi (exemple: le Asus RT-AX86U Pro), mais ils peuvent Ãªtre coÃ»teux et ne pas offrir autant de flexibilitÃ© que la crÃ©ation de votre propre routeur VPN Ã  lâ€™aide dâ€™un Raspberry Pi, Ã  moindre coÃ»t.\nDans ce tuto, je vais vous montrer comment transformer un Raspberry Pi en un client VPN matÃ©riel. Cette configuration vous permettra de router le trafic rÃ©seau de tous vos appareils Ã  travers un serveur VPN Ã  lâ€™aide dâ€™un Raspberry Pi.\nPrÃ©-requis: Un Raspberry Pi Un carte microSD (8GB ou plus) pour Raspbian OS Un dongle USB Wifi Un accÃ¨s internet Un fournisseur de VPN avec un fichier de configuration .ovpn (Un serveur OpenVPN auto-hÃ©bergÃ© ou un service comme NordVPN, CyberGhost, etc.) Etape 1. Installation de lâ€™OS sur le Raspberry Pi a. TÃ©lÃ©chargement de Raspberry Pi OS TÃ©lÃ©chargez Raspberry Pi OS (Lite version recommandÃ©e pour un usage de routeur) depuis le site officiel Raspberry Pi. Flash lâ€™image sur une carte microSD en utilisant un outil comme Raspberry Pi Imager ou Balena Etcher. b. Configuration initiale InsÃ©rez la carte microSD dans le Raspberry Pi et dÃ©marrez-le. Connectez-vous via SSH (ou directement avec clavier et Ã©cran) : Par dÃ©faut, le nom dâ€™utilisateur est pi et le mot de passe est raspberry. Changez le mot de passe par dÃ©faut pour des raisons de sÃ©curitÃ© : 1 passwd Mettez Ã  jour les packages du systÃ¨me : 1 sudo apt-get update \u0026\u0026 sudo apt-get upgrade -y Etape 2. Installation du daemon OpenVPN a. Installation dâ€™OpenVPN Installez OpenVPN : 1 sudo apt-get install openvpn -y b. Configuration dâ€™OpenVPN Copiez ou crÃ©ez un fichier de configuration .ovpn pour le serveur VPN auquel vous souhaitez vous connecter. Ce fichier contient les paramÃ¨tres de connexion, les certificats et les clÃ©s nÃ©cessaires. Il est fourni par votre fournisseur de VPN. Placez le fichier de configuration dans le rÃ©pertoire /etc/openvpn/ et renommez-le en client.conf pour quâ€™OpenVPN le dÃ©tecte automatiquement : 1 sudo cp /path/to/your/client.ovpn /etc/openvpn/client.conf DÃ©marrez OpenVPN : 1 sudo systemctl start openvpn@client VÃ©rifiez le statut dâ€™OpenVPN pour vous assurer quâ€™il est connectÃ© : 1 sudo systemctl status openvpn@client Etape 3. Mise en place du routage Pour permettre au Raspberry Pi de router le trafic entre les interfaces eth0 (le rÃ©seau local) et tun0 (connexion VPN), nous devons activer le routage IP et configurer le NAT (Network Address Translation).\na. Activer le routage IP Activez le routage IP sur le Raspberry Pi : 1 sudo sysctl -w net.ipv4.ip_forward=1 Rendre la configuration permanente en modifiant /etc/sysctl.conf : 1 sudo nano /etc/sysctl.conf Ajoutez ou dÃ©commentez la ligne suivante : 1 net.ipv4.ip_forward = 1 Rechargez la configuration : 1 sudo sysctl -p b. Configurer le NAT avec iptables Configurez le NAT pour permettre le routage du trafic sortant via lâ€™interface VPN (tun0) : 1 sudo iptables -t nat -A POSTROUTING -o tun0 -j MASQUERADE Permettez le trafic entre eth0 et tun0 : 1 2 sudo iptables -A FORWARD -i eth0 -o tun0 -j ACCEPT sudo iptables -A FORWARD -i tun0 -o eth0 -m state --state RELATED,ESTABLISHED -j ACCEPT Sauvegardez les rÃ¨gles iptables pour quâ€™elles persistent aprÃ¨s un redÃ©marrage : 1 sudo sh -c \"iptables-save \u003e /etc/iptables/rules.v4\" Etape 4. Installation du serveur DHCP Pour attribuer des adresses IP aux appareils connectÃ©s au Raspberry Pi, nous allons installer un serveur DHCP (Dynamic Host Configuration Protocol).\na. Installation du serveur DHCP Installez ISC DHCP Server : 1 sudo apt-get install isc-dhcp-server -y b. Configuration du serveur DHCP Configurez le fichier /etc/dhcp/dhcpd.conf : 1 sudo nano /etc/dhcp/dhcpd.conf Ajoutez les paramÃ¨tres suivants pour le rÃ©seau eth0 : 1 2 3 4 5 6 7 8 9 10 default-lease-time 600; max-lease-time 7200; option domain-name \"localhost.local\"; option domain-name-servers 8.8.8.8, 8.8.4.4; subnet 192.168.1.0 netmask 255.255.255.0 { range 192.168.1.10 192.168.1.50; option routers 192.168.1.1; option broadcast-address 192.168.1.255; } c. Configurer lâ€™interface eth0 pour DHCP DÃ©finissez eth0 comme lâ€™interface pour le serveur DHCP : 1 sudo nano /etc/default/isc-dhcp-server Modifiez la ligne suivante : 1 INTERFACESv4=\"eth0\" d. DÃ©marrer le serveur DHCP DÃ©marrez le serveur DHCP et configurez-le pour dÃ©marrer au boot : 1 2 sudo systemctl start isc-dhcp-server sudo systemctl enable isc-dhcp-server e. Attribition dâ€™un adresse fixe Ã  lâ€™interface eth0 Attribuez lâ€™adresse IP 192.168.1.1 Ã  eth0 de maniÃ¨re permanente : 1 sudo nano /etc/dhcpcd.conf Ajoutez Ã  la fin du fichier : 1 2 interface eth0 static ip_address=192.168.1.1/24 RedÃ©marrez le service rÃ©seau pour appliquer la configuration : 1 sudo systemctl restart dhcpcd Conclusion VoilÃ ! Votre Raspberry Pi est maintenant configurÃ© en tant que client VPN matÃ©riel. Tous les appareils connectÃ©s au Raspberry Pi via lâ€™interface eth0 utiliseront la connexion VPN pour accÃ©der Ã  Internet de maniÃ¨re sÃ©curisÃ©e. ","description":"Une procÃ©dure complÃ¨te pour mettre en place un routeur VPN Ã  partir dâ€™un Raspberry Pi.","tags":["network","raspberry","vpn"],"title":"Routeur VPN","uri":"/posts/2024-09-05-routeur-vpn/"},{"categories":["Divers"],"content":"Hello World! Bienvenue sur mon blogâ€¯!\nCeci est mon tout premier article. Jâ€™ai crÃ©Ã© ce blog pour partager mes idÃ©es, mes dÃ©couvertes et mes projets autour du dÃ©veloppement, de la technologie et bien plus encore.\nDans les prochains articles, je parlerai de sujets variÃ©s, partagerai des tutoriels, des astuces et des retours dâ€™expÃ©rience.\nNâ€™hÃ©sitez pas Ã  laisser un commentaire ou Ã  me contacter si vous avez des questions ou des suggestions.\nMerci de votre visite et Ã  trÃ¨s bientÃ´t pour de nouveaux articlesâ€¯!\n","description":"Bonjour le monde","tags":["PrÃ©sentation"],"title":"Hello World","uri":"/posts/world/"}]
